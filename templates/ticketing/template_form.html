{% extends "shared/generic/generic_form.html" %}
{% load i18n %}
{% load json_filters %}
{% load static %}

{% block form_sections %}
<!-- Template Information Section -->
<div class="form-section">
  <h2>{% trans "Template Information" %}</h2>
  {% for field in form %}
    <div class="form-field">
      <label for="{{ field.id_for_label }}">
        {{ field.label }}
        {% if field.field.required %}*{% endif %}
      </label>
      {{ field }}
      {% if field.errors %}
        <span class="error">{{ field.errors.0 }}</span>
      {% endif %}
      {% if field.help_text %}
        <small class="form-text">{{ field.help_text }}</small>
      {% endif %}
    </div>
  {% endfor %}
</div>

    <!-- Template Fields Section -->
    <div class="form-section">
      <header class="section-header">
        <h2>{% trans "Template Fields" %}</h2>
        <p>{% trans "Define the fields that will be used in tickets created from this template. Add fields one by one by filling the blank row." %}</p>
      </header>

      {{ field_formset.management_form }}
      {% if field_formset.non_form_errors %}
        <div class="alert alert-error">
          {{ field_formset.non_form_errors }}
        </div>
      {% endif %}

      <div class="fields-container">
        <table class="data-table formset-table">
          <thead>
            <tr>
              <th>{% trans "Order" %}</th>
              <th>{% trans "Field Name" %}</th>
              <th>{% trans "Field Type" %}</th>
              <th>{% trans "Field Key" %}</th>
              <th>{% trans "Required" %}</th>
              <th>{% trans "Default Value" %}</th>
              <th>{% trans "Status" %}</th>
              <th>{% trans "Delete" %}</th>
              <th>{% trans "Remove" %}</th>
              <th>{% trans "Settings" %}</th>
            </tr>
          </thead>
          <tbody id="field-formset-body">
            {% for field_form in field_formset %}
              <tr class="field-form-row">
                {% for hidden in field_form.hidden_fields %}{{ hidden }}{% endfor %}
                <td>
                  {{ field_form.field_order }}
                  {% for error in field_form.field_order.errors %}
                    <div class="field-error">{{ error }}</div>
                  {% endfor %}
                </td>
                <td>
                  {{ field_form.field_name }}
                  {% for error in field_form.field_name.errors %}
                    <div class="field-error">{{ error }}</div>
                  {% endfor %}
                </td>
                <td>
                  {{ field_form.field_type }}
                  {% for error in field_form.field_type.errors %}
                    <div class="field-error">{{ error }}</div>
                  {% endfor %}
                </td>
                <td>
                  {{ field_form.field_key }}
                  {% for error in field_form.field_key.errors %}
                    <div class="field-error">{{ error }}</div>
                  {% endfor %}
                </td>
                <td class="text-center">
                  {{ field_form.is_required }}
                  {% for error in field_form.is_required.errors %}
                    <div class="field-error">{{ error }}</div>
                  {% endfor %}
                </td>
                <td>
                  {{ field_form.default_value }}
                  {% for error in field_form.default_value.errors %}
                    <div class="field-error">{{ error }}</div>
                  {% endfor %}
                </td>
                <td>
                  {{ field_form.is_enabled }}
                  {% for error in field_form.is_enabled.errors %}
                    <div class="field-error">{{ error }}</div>
                  {% endfor %}
                </td>
                <td>
                  {% if field_form.instance.pk %}
                    {{ field_form.DELETE }}
                    <label for="{{ field_form.DELETE.id_for_label }}" class="ml-2">{% trans "Delete" %}</label>
                  {% else %}
                    <span class="muted-text">‚Äì</span>
                  {% endif %}
                </td>
                <td class="text-center">
                  {% if not field_form.instance.pk %}
                    <button type="button" class="btn btn-sm btn-danger remove-field-row" data-field-index="{{ forloop.counter0 }}">
                      üóëÔ∏è {% trans "Remove" %}
                    </button>
                  {% else %}
                    <span class="muted-text">‚Äì</span>
                  {% endif %}
                </td>
                <td class="text-center">
                  <button type="button" class="btn btn-sm btn-secondary toggle-field-settings" data-field-index="{{ forloop.counter0 }}">
                    <span>‚öôÔ∏è</span> {% trans "Settings" %}
                  </button>
                </td>
              </tr>
              <!-- Field Settings Row (Collapsible) -->
              <tr class="field-settings-row hidden" id="field-settings-{{ forloop.counter0 }}" data-field-type="{{ field_form.field_type.value|default:'' }}">
                <td colspan="10" class="field-settings-cell">
                  <div class="field-settings-panel" data-field-index="{{ forloop.counter0 }}">
                    <h4 class="field-settings-title">{% trans "Field Settings" %}</h4>
                    
                    <!-- Common Settings (always visible) -->
                    <div class="form-field field-settings-field">
                      <label>{{ field_form.help_text.label }}</label>
                      {{ field_form.help_text }}
                      {% for error in field_form.help_text.errors %}
                        <div class="field-error">{{ error }}</div>
                      {% endfor %}
                    </div>
                    
                    <!-- Dynamic Field-Specific Settings (loaded via JavaScript) -->
                    <div class="field-specific-settings" data-field-index="{{ forloop.counter0 }}">
                      <!-- Settings will be dynamically loaded here based on field_type -->
                    </div>
                    
                    <!-- Hidden field_config for storing settings as JSON -->
                    {% if field_form.instance.pk and field_form.instance.field_config %}
                      <input type="hidden" 
                             name="{{ field_form.field_config.html_name }}" 
                             id="{{ field_form.field_config.id_for_label }}"
                             value="{{ field_form.instance.field_config|to_json }}" 
                             class="field-config-json-input" />
                    {% else %}
                      <input type="hidden" 
                             name="{{ field_form.field_config.html_name }}" 
                             id="{{ field_form.field_config.id_for_label }}"
                             value="{% if field_form.field_config.value %}{{ field_form.field_config.value|safe }}{% else %}{}{% endif %}" 
                             class="field-config-json-input" />
                    {% endif %}
                    
                    <!-- Validation Rules (JSON) - Optional for all fields -->
                    <div class="form-field field-settings-field">
                      <label>{% trans "Validation Rules (JSON)" %}</label>
                      {{ field_form.validation_rules }}
                      <small class="form-text">
                        {% trans "JSON rules for field validation (min_length, max_length, pattern, etc.)" %}
                      </small>
                    </div>
                  </div>
                </td>
              </tr>
            {% endfor %}
          </tbody>
        </table>
        <button type="button" id="add-field-row" class="btn btn-secondary btn-add-formset-row">
          + {% trans "Add Field" %}
        </button>
        <p class="muted-text form-text-mt">
          {% trans "Note: After saving, you can edit individual fields to add options (for radio/dropdown fields) and events." %}
        </p>
      </div>
      
      <!-- Empty form template for field formset -->
      <template id="empty-field-form">
        <tr class="field-form-row">
          {% for hidden in field_formset.empty_form.hidden_fields %}{{ hidden }}{% endfor %}
          <td>
            {{ field_formset.empty_form.field_order }}
          </td>
          <td>
            {{ field_formset.empty_form.field_name }}
          </td>
          <td>
            {{ field_formset.empty_form.field_type }}
          </td>
          <td>
            {{ field_formset.empty_form.field_key }}
          </td>
          <td class="text-center">
            {{ field_formset.empty_form.is_required }}
          </td>
          <td>
            {{ field_formset.empty_form.default_value }}
          </td>
          <td>
            {{ field_formset.empty_form.is_enabled }}
          </td>
          <td class="text-center">
            <button type="button" class="btn btn-sm btn-danger remove-field-row" data-field-index="__prefix__">
              üóëÔ∏è {% trans "Remove" %}
            </button>
          </td>
          <td class="text-center">
            <button type="button" class="btn btn-sm btn-secondary toggle-field-settings" data-field-index="__prefix__">
              ‚öôÔ∏è {% trans "Settings" %}
            </button>
          </td>
        </tr>
        <!-- Field Settings Row (Collapsible) - Empty Form -->
        <tr class="field-settings-row hidden" id="field-settings-__prefix__" data-field-type="">
          <td colspan="10" class="field-settings-cell field-settings-cell-template">
            <div class="field-settings-panel" data-field-index="__prefix__">
              <h4 class="field-settings-title">{% trans "Field Settings" %}</h4>
              
              <!-- Help Text -->
              <div class="form-field" style="margin-bottom: 1rem;">
                <label>{{ field_formset.empty_form.help_text.label }}</label>
                {{ field_formset.empty_form.help_text }}
              </div>
              
              <!-- Dynamic Field-Specific Settings (loaded via JavaScript) -->
              <div class="field-specific-settings" data-field-index="__prefix__">
                <!-- Settings will be dynamically loaded here based on field_type -->
              </div>
              
              <!-- Hidden field_config for storing settings as JSON -->
              <input type="hidden" 
                     name="{{ field_formset.empty_form.field_config.html_name }}" 
                     id="{{ field_formset.empty_form.field_config.id_for_label }}"
                     value="" 
                     class="field-config-json-input" />
              
              <!-- Validation Rules (JSON) -->
              <div class="form-field" style="margin-bottom: 1rem;">
                <label>{{ field_formset.empty_form.validation_rules.label }}</label>
                {{ field_formset.empty_form.validation_rules }}
                <small class="form-text">
                  {% trans "JSON rules for field validation (min_length, max_length, pattern, etc.)" %}
                </small>
              </div>
            </div>
          </td>
        </tr>
      </template>
    </div>

    <!-- Template Permissions Section -->
    <div class="form-section">
      <header class="section-header">
        <h2>{% trans "Permissions" %}</h2>
        <p>{% trans "Define which users or groups can create, respond to, or close tickets using this template." %}</p>
      </header>

      {{ permission_formset.management_form }}
      {% if permission_formset.non_form_errors %}
        <div class="alert alert-error">
          {{ permission_formset.non_form_errors }}
        </div>
      {% endif %}

      <table class="data-table formset-table">
        <thead>
          <tr>
            <th>{% trans "User" %}</th>
            <th>{% trans "Group" %}</th>
            <th>{% trans "Can Create" %}</th>
            <th>{% trans "Can Respond" %}</th>
            <th>{% trans "Can Close" %}</th>
            <th>{% trans "Status" %}</th>
            <th>{% trans "Delete" %}</th>
          </tr>
        </thead>
        <tbody id="permission-formset-body">
          {% for perm_form in permission_formset %}
            <tr>
              {% for hidden in perm_form.hidden_fields %}{{ hidden }}{% endfor %}
              <td>
                {{ perm_form.user }}
                {% for error in perm_form.user.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
              </td>
              <td>
                {{ perm_form.group }}
                {% for error in perm_form.group.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
              </td>
              <td class="text-center">
                {{ perm_form.can_create }}
                {% for error in perm_form.can_create.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
              </td>
              <td class="text-center">
                {{ perm_form.can_respond }}
                {% for error in perm_form.can_respond.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
              </td>
              <td class="text-center">
                {{ perm_form.can_close }}
                {% for error in perm_form.can_close.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
              </td>
              <td>
                {{ perm_form.is_enabled }}
                {% for error in perm_form.is_enabled.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
              </td>
              <td>
                {% if perm_form.instance.pk %}
                  {{ perm_form.DELETE }}
                  <label for="{{ perm_form.DELETE.id_for_label }}" class="ml-2">{% trans "Delete" %}</label>
                {% else %}
                  <button type="button" class="btn btn-sm btn-danger remove-permission-row" data-permission-index="{{ forloop.counter0 }}">
                    üóëÔ∏è {% trans "Remove" %}
                  </button>
                {% endif %}
              </td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
      <button type="button" id="add-permission-row" class="btn btn-secondary btn-add-formset-row">
        + {% trans "Add Permission" %}
      </button>
      
      <!-- Empty form template for permission formset -->
      <template id="empty-permission-form">
        <tr>
          {% for hidden in permission_formset.empty_form.hidden_fields %}{{ hidden }}{% endfor %}
          <td>
            {{ permission_formset.empty_form.user }}
          </td>
          <td>
            {{ permission_formset.empty_form.group }}
          </td>
          <td class="text-center">
            {{ permission_formset.empty_form.can_create }}
          </td>
          <td class="text-center">
            {{ permission_formset.empty_form.can_respond }}
          </td>
          <td class="text-center">
            {{ permission_formset.empty_form.can_close }}
          </td>
          <td>
            {{ permission_formset.empty_form.is_enabled }}
          </td>
          <td>
            <button type="button" class="btn btn-sm btn-danger remove-permission-row" data-permission-index="__prefix__">
              üóëÔ∏è {% trans "Remove" %}
            </button>
          </td>
        </tr>
      </template>
    </div>

    <!-- Template Events Section -->
    <div class="form-section">
      <header class="section-header">
        <h2>{% trans "Template Events" %}</h2>
        <p>{% trans "Define actions that will be executed when specific events occur (e.g., when a ticket is opened or closed). Use Entity Reference System syntax." %}</p>
      </header>

      {{ event_formset.management_form }}
      {% if event_formset.non_form_errors %}
        <div class="alert alert-error">
          {{ event_formset.non_form_errors }}
        </div>
      {% endif %}

      <table class="data-table formset-table">
        <thead>
          <tr>
            <th>{% trans "Event Type" %}</th>
            <th>{% trans "Order" %}</th>
            <th>{% trans "Action Reference" %}</th>
            <th>{% trans "Condition Rules (JSON)" %}</th>
            <th>{% trans "Status" %}</th>
            <th>{% trans "Delete" %}</th>
          </tr>
        </thead>
        <tbody id="event-formset-body">
          {% for event_form in event_formset %}
            <tr>
              {% for hidden in event_form.hidden_fields %}{{ hidden }}{% endfor %}
              <td>
                {{ event_form.event_type }}
                {% for error in event_form.event_type.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
              </td>
              <td>
                {{ event_form.event_order }}
                {% for error in event_form.event_order.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
              </td>
              <td>
                {{ event_form.action_reference }}
                {% for error in event_form.action_reference.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
                <small class="form-text">{% trans "Example: users:show:gp=superuser or 0270:approve:code={ticket.reference_code}" %}</small>
              </td>
              <td>
                {{ event_form.condition_rules }}
                {% for error in event_form.condition_rules.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
                <small class="form-text">{% trans "Example: {\"field_key\": \"priority\", \"operator\": \"equals\", \"value\": \"high\"}" %}</small>
              </td>
              <td>
                {{ event_form.is_enabled }}
                {% for error in event_form.is_enabled.errors %}
                  <div class="field-error">{{ error }}</div>
                {% endfor %}
              </td>
              <td>
                {% if event_form.instance.pk %}
                  {{ event_form.DELETE }}
                  <label for="{{ event_form.DELETE.id_for_label }}" class="ml-2">{% trans "Delete" %}</label>
                {% else %}
                  <span class="muted-text">‚Äì</span>
                {% endif %}
              </td>
            </tr>
          {% endfor %}
        </tbody>
      </table>
      <button type="button" id="add-event-row" class="btn btn-secondary btn-add-formset-row">
        + {% trans "Add Event" %}
      </button>
      
      <!-- Empty form template for event formset -->
      <div id="empty-event-form" class="hidden">
        <tr>
          {% for hidden in event_formset.empty_form.hidden_fields %}{{ hidden }}{% endfor %}
          <td>
            {{ event_formset.empty_form.event_type }}
          </td>
          <td>
            {{ event_formset.empty_form.event_order }}
          </td>
          <td>
            {{ event_formset.empty_form.action_reference }}
            <small class="form-text">{% trans "Example: users:show:gp=superuser or 0270:approve:code={ticket.reference_code}" %}</small>
          </td>
          <td>
            {{ event_formset.empty_form.condition_rules }}
            <small class="form-text">{% trans "Example: {\"field_key\": \"priority\", \"operator\": \"equals\", \"value\": \"high\"}" %}</small>
          </td>
          <td>
            {{ event_formset.empty_form.is_enabled }}
          </td>
          <td>
            <span class="muted-text">‚Äì</span>
          </td>
        </tr>
      </div>
    </div>
{% endblock %}

{% block form_extra %}
<link rel="stylesheet" href="{% static 'css/shared.css' %}">
<link rel="stylesheet" href="{% static 'css/formset-table.css' %}">

<script>
document.addEventListener('DOMContentLoaded', function() {
  // ========================================================================
  // Field Formset
  // ========================================================================
  const fieldFormsetBody = document.getElementById('field-formset-body');
  const addFieldButton = document.getElementById('add-field-row');
  
  if (!fieldFormsetBody || !addFieldButton) {
    return;
  }
  
  // Find management form - look in the form section
  const section = fieldFormsetBody.closest('.form-section');
  let fieldManagementForm = null;
  
  // Find the management form input - Django creates it in management_form
  if (section) {
    // Look for input with name ending in -TOTAL_FORMS within this section
    const allInputs = section.querySelectorAll('input');
    for (let i = 0; i < allInputs.length; i++) {
      const input = allInputs[i];
      if (input.name && input.name.endsWith('-TOTAL_FORMS')) {
        fieldManagementForm = input;
        break;
      }
    }
  }
  
  const emptyFieldForm = document.getElementById('empty-field-form');
  
  if (!emptyFieldForm) {
    return;
  }
  
  // Try to find management form if not found yet
  if (!fieldManagementForm) {
    // Try to find it in the entire form
    const form = fieldFormsetBody.closest('form');
    if (form) {
      const allManagementForms = form.querySelectorAll('input[name$="-TOTAL_FORMS"]');
      if (allManagementForms.length > 0) {
        // Try to find the one in the fields section first
        const section = fieldFormsetBody.closest('.form-section');
        for (let i = 0; i < allManagementForms.length; i++) {
          const mf = allManagementForms[i];
          if (section && section.contains(mf)) {
            fieldManagementForm = mf;
            break;
          }
        }
        // If still not found, use the first one (fallback)
        if (!fieldManagementForm && allManagementForms.length > 0) {
          fieldManagementForm = allManagementForms[0];
        }
      }
    }
  }
  
  // Add event listener for adding new rows
  addFieldButton.addEventListener('click', function(e) {
    e.preventDefault();
    e.stopPropagation();
    
    // Find management form if not already found
    let mgmtForm = fieldManagementForm;
    if (!mgmtForm) {
      const form = fieldFormsetBody.closest('form');
      if (form) {
        const allManagementForms = form.querySelectorAll('input[name$="-TOTAL_FORMS"]');
        if (allManagementForms.length > 0) {
          const section = fieldFormsetBody.closest('.form-section');
          for (let i = 0; i < allManagementForms.length; i++) {
            const mf = allManagementForms[i];
            if (section && section.contains(mf)) {
              mgmtForm = mf;
              break;
            }
          }
          if (!mgmtForm) {
            mgmtForm = allManagementForms[0];
          }
        }
      }
    }
    
    if (!mgmtForm) {
      return;
    }
    
    const totalForms = parseInt(mgmtForm.value) || 0;
    
    // Get the field row template from template tag (use .content for template elements)
    const templateContent = emptyFieldForm.content || emptyFieldForm;
    const fieldRowTemplate = templateContent.querySelector('tr.field-form-row');
    const settingsRowTemplate = templateContent.querySelector('tr.field-settings-row');
    
    if (!fieldRowTemplate) {
      return;
    }
    
    // Clone the rows directly
    const newFieldRow = fieldRowTemplate.cloneNode(true);
    const newSettingsRow = settingsRowTemplate ? settingsRowTemplate.cloneNode(true) : null;
    
    // Update all form field names and IDs using __prefix__ replacement
    function updateFieldNames(element) {
      if (!element) return;
      const formFields = element.querySelectorAll('input, select, textarea, label, button');
      formFields.forEach(function(field) {
        if (field.name && field.name.includes('__prefix__')) {
          field.name = field.name.replace(/__prefix__/g, totalForms);
        }
        if (field.id && field.id.includes('__prefix__')) {
          field.id = field.id.replace(/__prefix__/g, totalForms);
        }
        if (field.getAttribute('for') && field.getAttribute('for').includes('__prefix__')) {
          field.setAttribute('for', field.getAttribute('for').replace(/__prefix__/g, totalForms));
        }
        // Update data attributes
        if (field.hasAttribute('data-field-index') && field.getAttribute('data-field-index') === '__prefix__') {
          field.setAttribute('data-field-index', totalForms);
        }
      });
    }
    
    updateFieldNames(newFieldRow);
    if (newSettingsRow) {
      newSettingsRow.id = 'field-settings-' + totalForms;
      updateFieldNames(newSettingsRow);
      
      // Initialize field settings for the new row
      const fieldTypeSelect = newFieldRow.querySelector('select[name*="field_type"]');
      if (fieldTypeSelect) {
        // Set default field type to trigger settings update
        const defaultFieldType = fieldTypeSelect.value || 'short_text';
        newSettingsRow.setAttribute('data-field-type', defaultFieldType);
        
        // Generate initial settings HTML
        setTimeout(function() {
          updateFieldSettings(newFieldRow, defaultFieldType);
        }, 100);
      }
    }
    
    // Add the new field row to tbody
    fieldFormsetBody.appendChild(newFieldRow);
    
    // Add the settings row right after the field row
    if (newSettingsRow) {
      fieldFormsetBody.appendChild(newSettingsRow);
    }
    
    // Update the total forms count
    mgmtForm.value = totalForms + 1;
  });
  
  // Handle delete checkboxes for fields (for existing saved fields)
  fieldFormsetBody.addEventListener('change', function(e) {
    if (e.target.type === 'checkbox' && e.target.name && e.target.name.includes('DELETE')) {
      const row = e.target.closest('.field-form-row');
      if (row && e.target.checked) {
        row.style.opacity = '0.5';
        // Also hide the settings row if it exists
        const settingsRow = row.nextElementSibling;
        if (settingsRow && settingsRow.classList.contains('field-settings-row')) {
          settingsRow.style.opacity = '0.5';
        }
      } else if (row) {
        row.style.opacity = '1';
        const settingsRow = row.nextElementSibling;
        if (settingsRow && settingsRow.classList.contains('field-settings-row')) {
          settingsRow.style.opacity = '1';
        }
      }
    }
  });
  
  // Handle remove button clicks (for newly added rows that aren't saved yet)
  fieldFormsetBody.addEventListener('click', function(e) {
    if (e.target.closest('.remove-field-row')) {
      e.preventDefault();
      e.stopPropagation();
      const button = e.target.closest('.remove-field-row');
      const fieldRow = button.closest('tr.field-form-row');
      
      if (fieldRow) {
        // Find and remove the settings row if it exists (next sibling)
        let nextRow = fieldRow.nextElementSibling;
        if (nextRow && nextRow.classList.contains('field-settings-row')) {
          nextRow.remove();
        }
        
        // Remove the field row
        fieldRow.remove();
        
        // Update the total forms count - find management form again if needed
        let mgmtForm = fieldManagementForm;
        if (!mgmtForm) {
          const form = fieldFormsetBody.closest('form');
          if (form) {
            const allManagementForms = form.querySelectorAll('input[name$="-TOTAL_FORMS"]');
            if (allManagementForms.length > 0) {
              const section = fieldFormsetBody.closest('.form-section');
              for (let i = 0; i < allManagementForms.length; i++) {
                const mf = allManagementForms[i];
                if (section && section.contains(mf)) {
                  mgmtForm = mf;
                  break;
                }
              }
              if (!mgmtForm) {
                mgmtForm = allManagementForms[0];
              }
            }
          }
        }
        
        if (mgmtForm) {
          const currentTotal = parseInt(mgmtForm.value) || 0;
          if (currentTotal > 0) {
            mgmtForm.value = currentTotal - 1;
          }
        }
      }
    }
  });
  
  // ========================================================================
  // Permission Formset
  // ========================================================================
  const permissionFormsetBody = document.getElementById('permission-formset-body');
  const addPermissionButton = document.getElementById('add-permission-row');
  // Find management form dynamically
  const permissionManagementForm = permissionFormsetBody ? 
    permissionFormsetBody.closest('.form-section').querySelector('input[name$="-TOTAL_FORMS"]') : null;
  
  if (permissionFormsetBody && addPermissionButton) {
    // Find management form dynamically
    let permissionManagementForm = permissionFormsetBody.closest('.form-section').querySelector('input[name$="-TOTAL_FORMS"]');
    if (!permissionManagementForm) {
      const form = permissionFormsetBody.closest('form');
      if (form) {
        const allInputs = form.querySelectorAll('input[name$="-TOTAL_FORMS"]');
        const section = permissionFormsetBody.closest('.form-section');
        for (let i = 0; i < allInputs.length; i++) {
          if (section && section.contains(allInputs[i])) {
            permissionManagementForm = allInputs[i];
            break;
          }
        }
        if (!permissionManagementForm && allInputs.length > 0) {
          permissionManagementForm = allInputs[0];
        }
      }
    }
    
    if (permissionManagementForm) {
      const emptyPermissionForm = document.getElementById('empty-permission-form');
      
      if (emptyPermissionForm) {
        addPermissionButton.addEventListener('click', function() {
          const totalForms = parseInt(permissionManagementForm.value) || 0;
          
          // Clone the empty form template (use .content for template tag)
          const templateContent = emptyPermissionForm.content || emptyPermissionForm;
          const newRow = templateContent.querySelector('tr').cloneNode(true);
          
          // Update all form field names and IDs to use the new index
          const formFields = newRow.querySelectorAll('input, select, textarea, label, button');
          formFields.forEach(function(field) {
            if (field.name) {
              field.name = field.name.replace(/__prefix__/g, totalForms);
            }
            if (field.id) {
              field.id = field.id.replace(/__prefix__/g, totalForms);
            }
            if (field.getAttribute('for')) {
              field.setAttribute('for', field.getAttribute('for').replace(/__prefix__/g, totalForms));
            }
            if (field.getAttribute('data-permission-index')) {
              field.setAttribute('data-permission-index', totalForms);
            }
          });
          
          // Add the new row to the formset body
          permissionFormsetBody.appendChild(newRow);
          
          // Update the total forms count
          permissionManagementForm.value = totalForms + 1;
        });
      }
    }
    
    // Handle remove button clicks for new permission rows
    permissionFormsetBody.addEventListener('click', function(e) {
      if (e.target.closest('.remove-permission-row')) {
        const button = e.target.closest('.remove-permission-row');
        const row = button.closest('tr');
        if (row) {
          row.remove();
          
          // Update the total forms count
          let mgmtForm = permissionFormsetBody.closest('.form-section').querySelector('input[name$="-TOTAL_FORMS"]');
          if (!mgmtForm) {
            const form = permissionFormsetBody.closest('form');
            if (form) {
              const allInputs = form.querySelectorAll('input[name$="-TOTAL_FORMS"]');
              const section = permissionFormsetBody.closest('.form-section');
              for (let i = 0; i < allInputs.length; i++) {
                if (section && section.contains(allInputs[i])) {
                  mgmtForm = allInputs[i];
                  break;
                }
              }
            }
          }
          
          if (mgmtForm) {
            const currentTotal = parseInt(mgmtForm.value) || 0;
            if (currentTotal > 0) {
              mgmtForm.value = currentTotal - 1;
            }
          }
        }
      }
    });
    
    // Handle delete checkboxes for permissions (for existing saved rows)
    permissionFormsetBody.addEventListener('change', function(e) {
      if (e.target.type === 'checkbox' && e.target.name && e.target.name.includes('DELETE')) {
        const row = e.target.closest('tr');
        if (row && e.target.checked) {
          row.style.opacity = '0.5';
        } else if (row) {
          row.style.opacity = '1';
        }
      }
    });
  }
  
  // ========================================================================
  // Event Formset
  // ========================================================================
  const eventFormsetBody = document.getElementById('event-formset-body');
  const addEventButton = document.getElementById('add-event-row');
  // Find management form dynamically
  const eventManagementForm = eventFormsetBody ? 
    eventFormsetBody.closest('.form-section').querySelector('input[name$="-TOTAL_FORMS"]') : null;
  
  if (eventFormsetBody && addEventButton && eventManagementForm) {
    const emptyEventForm = document.getElementById('empty-event-form');
    
    addEventButton.addEventListener('click', function() {
      const totalForms = parseInt(eventManagementForm.value);
      
      // Clone the empty form template
      const newRow = emptyEventForm.querySelector('tr').cloneNode(true);
      
      // Update all form field names and IDs to use the new index
      const formFields = newRow.querySelectorAll('input, select, textarea, label');
      formFields.forEach(function(field) {
        if (field.name) {
          field.name = field.name.replace(/__prefix__/g, totalForms);
        }
        if (field.id) {
          field.id = field.id.replace(/__prefix__/g, totalForms);
        }
        if (field.getAttribute('for')) {
          field.setAttribute('for', field.getAttribute('for').replace(/__prefix__/g, totalForms));
        }
      });
      
      // Add the new row to the formset body
      eventFormsetBody.appendChild(newRow);
      
      // Update the total forms count
      eventManagementForm.value = totalForms + 1;
    });
    
    // Handle delete checkboxes for events
    eventFormsetBody.addEventListener('change', function(e) {
      if (e.target.type === 'checkbox' && e.target.name && e.target.name.includes('DELETE')) {
        const row = e.target.closest('tr');
        if (row && e.target.checked) {
          row.style.opacity = '0.5';
        } else if (row) {
          row.style.opacity = '1';
        }
      }
    });
  }
  
  // ========================================================================
  // Dynamic Field Settings Based on Field Type
  // ========================================================================
  
  // Field-specific settings configuration
  const FIELD_SETTINGS_CONFIG = {
    // Fields with no special settings (only help_text)
    'short_text': { type: 'none' },
    'long_text': { type: 'none' },
    'rich_text': { type: 'none' },
    'email': { type: 'none' },
    'url': { type: 'none' },
    'phone': { type: 'none' },
    'file_upload': { type: 'none' },
    'color': { type: 'none' },
    'currency': { type: 'none' },
    'signature': { type: 'none' },
    'location': { type: 'none' },
    'section': { type: 'none' },
    'tags': { type: 'none' },
    
    // Options fields (radio, dropdown, checkbox, multi_select)
    'radio': { type: 'options', sourceType: 'manual_or_entity' },
    'dropdown': { type: 'options', sourceType: 'manual_or_entity' },
    'checkbox': { type: 'options', sourceType: 'manual_or_entity' },
    'multi_select': { type: 'options', sourceType: 'manual_or_entity' },
    
    // Date/Time fields
    'date': { type: 'auto_fill', fieldName: 'auto_fill_date' },
    'time': { type: 'auto_fill', fieldName: 'auto_fill_time' },
    'datetime': { type: 'auto_fill', fieldName: 'auto_fill_datetime' },
    
    // Number fields
    'number': { type: 'number', settings: ['thousands_separator'] },
    'rating': { type: 'range', minField: 'min_rating', maxField: 'max_rating' },
    'slider': { type: 'range', minField: 'min_value', maxField: 'max_value', stepField: 'step_value' },
    
    // Calculation field
    'calculation': { type: 'formula', fieldName: 'formula' },
    
    // Reference field - not needed (use dropdown/multi_select with entity reference)
    'reference': { type: 'none' }
  };
  
  /**
   * Generate field-specific settings HTML based on field type
   */
  function generateFieldSettingsHTML(fieldType, fieldIndex, fieldConfig = {}) {
    const config = FIELD_SETTINGS_CONFIG[fieldType];
    if (!config) {
      return '<div class="form-text muted-text">{% trans "No special settings for this field type" %}</div>';
    }
    
    let html = '';
    const index = fieldIndex;
    
    switch (config.type) {
      case 'none':
        // No special settings needed
        html = '<div class="form-text muted-text">{% trans "No special settings required for this field type" %}</div>';
        break;
        
      case 'options':
        // Options management (manual or entity reference)
        html = `
          <div class="options-source-setting field-settings-field">
            <label style="display: block; font-weight: 500; margin-bottom: 0.5rem;">{% trans "Options Source" %}</label>
            <select name="fields-${index}-options_source" class="form-control options-source-select" style="margin-bottom: 0.5rem;">
              <option value="manual">{% trans "Manual" %}</option>
              <option value="entity_reference">{% trans "From Entity Reference" %}</option>
            </select>
          </div>
          
          <!-- Manual Options Management -->
          <div class="manual-options-panel" data-field-index="${index}" style="display: none;">
            <label style="display: block; font-weight: 500; margin-bottom: 0.5rem;">{% trans "Manage Options" %}</label>
            <div class="options-management-container" data-field-index="${index}">
              <table class="options-table" style="width: 100%; margin-bottom: 0.5rem; border-collapse: collapse;">
                <thead>
                  <tr style="background: #f3f4f6; border-bottom: 2px solid #e5e7eb;">
                    <th style="padding: 0.5rem; text-align: left; font-weight: 500; font-size: 0.875rem;">{% trans "Order" %}</th>
                    <th style="padding: 0.5rem; text-align: left; font-weight: 500; font-size: 0.875rem;">{% trans "Value" %}</th>
                    <th style="padding: 0.5rem; text-align: left; font-weight: 500; font-size: 0.875rem;">{% trans "Label" %}</th>
                    <th style="padding: 0.5rem; text-align: center; font-weight: 500; font-size: 0.875rem;">{% trans "Default" %}</th>
                    <th style="padding: 0.5rem; text-align: center; font-weight: 500; font-size: 0.875rem;">{% trans "Actions" %}</th>
                  </tr>
                </thead>
                <tbody class="options-list-body" data-field-index="${index}">
                  <!-- Options will be dynamically added here -->
                </tbody>
              </table>
              <button type="button" class="btn btn-sm btn-secondary add-option-btn" data-field-index="${index}" style="margin-top: 0.5rem;">
                + {% trans "Add Option" %}
              </button>
            </div>
          </div>
          
          <!-- Entity Reference Configuration -->
          <div class="entity-reference-panel" data-field-index="${index}" style="display: none;">
            <!-- Level 1: Section Selection -->
            <div class="form-field" style="margin-bottom: 1rem;">
              <label style="display: block; font-weight: 500; margin-bottom: 0.5rem;">{% trans "Section" %}</label>
              <select name="fields-${index}-entity_section" class="form-control entity-section-select" 
                      data-field-index="${index}">
                <option value="">{% trans "Select section..." %}</option>
                <!-- Options will be loaded via JavaScript -->
              </select>
              <small class="form-text">{% trans "Select a section/module from the application" %}</small>
            </div>
            
            <!-- Level 2: Action Selection -->
            <div class="form-field" style="margin-bottom: 1rem;">
              <label style="display: block; font-weight: 500; margin-bottom: 0.5rem;">{% trans "Action" %}</label>
              <select name="fields-${index}-entity_action" class="form-control entity-action-select" 
                      data-field-index="${index}" disabled>
                <option value="">{% trans "Select action..." %}</option>
                <!-- Options will be loaded via JavaScript when section is selected -->
              </select>
              <small class="form-text">{% trans "Select an action for the selected section" %}</small>
            </div>
            
            <!-- Level 3: Parameter Selection -->
            <div class="entity-parameters-container" data-field-index="${index}" style="margin-bottom: 1rem;">
              <label style="display: block; font-weight: 500; margin-bottom: 0.5rem;">{% trans "Parameter" %}</label>
              <select name="fields-${index}-entity_parameter" 
                      class="form-control entity-parameter-select" 
                      data-field-index="${index}" 
                      disabled>
                <option value="">{% trans "Select parameter..." %}</option>
                <!-- Options will be loaded when action is selected -->
              </select>
              <small class="form-text">{% trans "Select a parameter to configure (optional)" %}</small>
              
              <!-- Level 4: Parameter Value (Combobox) -->
              <div class="entity-parameter-value-container" data-field-index="${index}" style="margin-top: 1rem; display: none;">
                <label style="display: block; font-weight: 500; margin-bottom: 0.5rem;">{% trans "Parameter Value" %}</label>
                <div class="parameter-value-wrapper" style="position: relative;">
                  <input type="text" 
                         name="fields-${index}-entity_parameter_value" 
                         class="form-control entity-parameter-value-input" 
                         data-field-index="${index}"
                         placeholder="{% trans 'Type or select value...' %}"
                         autocomplete="off" />
                  <!-- Datalist will be created dynamically by JavaScript -->
                </div>
                <small class="form-text">{% trans "Type a value or select from the list" %}</small>
              </div>
            </div>
            
            <!-- Hidden container for storing all parameter data -->
            <div class="entity-parameters-list" data-field-index="${index}" style="display: none;">
              <!-- Internal storage for parameter schema -->
            </div>
            
            <!-- Hidden inputs for backward compatibility -->
            <input type="hidden" name="fields-${index}-entity_reference" class="entity-reference-hidden" 
                   data-field-index="${index}"
                   value="${fieldConfig.entity_reference || ''}" />
            <input type="hidden" name="fields-${index}-value_field" class="entity-value-field-hidden" 
                   data-field-index="${index}"
                   value="${fieldConfig.value_field || 'id'}" />
            <input type="hidden" name="fields-${index}-label_field" class="entity-label-field-hidden" 
                   data-field-index="${index}"
                   value="${fieldConfig.label_field || 'name'}" />
          </div>
        `;
        break;
        
      case 'auto_fill':
        // Auto-fill checkbox for date/time/datetime
        const labelText = {
          'auto_fill_date': '{% trans "Auto-fill with current date" %}',
          'auto_fill_time': '{% trans "Auto-fill with current time" %}',
          'auto_fill_datetime': '{% trans "Auto-fill with current date and time" %}'
        }[config.fieldName] || '{% trans "Auto-fill" %}';
        
        html = `
          <div class="form-field" style="margin-bottom: 0.5rem;">
            <label style="display: flex; align-items: center; gap: 0.5rem;">
              <input type="checkbox" name="fields-${index}-${config.fieldName}" 
                     class="form-check-input" 
                     ${fieldConfig[config.fieldName] ? 'checked' : ''} />
              <span>${labelText}</span>
            </label>
            <small class="form-text" style="display: block; margin-top: 0.25rem;">
              {% trans "If enabled, the field will be automatically filled with current date/time when creating a ticket" %}
            </small>
          </div>
        `;
        break;
        
      case 'number':
        // Number field: thousands separator
        html = `
          <div class="form-field" style="margin-bottom: 0.5rem;">
            <label style="display: flex; align-items: center; gap: 0.5rem;">
              <input type="checkbox" name="fields-${index}-thousands_separator" 
                     class="form-check-input" 
                     ${fieldConfig.thousands_separator ? 'checked' : ''} />
              <span>{% trans "Use thousands separator (3 digits, 3 digits)" %}</span>
            </label>
            <small class="form-text" style="display: block; margin-top: 0.25rem;">
              {% trans "If enabled, numbers will be displayed with thousand separators (e.g., 1,000,000)" %}
            </small>
          </div>
        `;
        break;
        
      case 'range':
        // Range fields: min, max, (optional step)
        html = `
          <div class="form-field" style="margin-bottom: 0.5rem;">
            <label style="display: block; font-weight: 500; margin-bottom: 0.25rem;">{% trans "Minimum Value" %}</label>
            <input type="number" name="fields-${index}-${config.minField}" 
                   class="form-control" 
                   value="${fieldConfig[config.minField] || ''}" 
                   placeholder="0" />
          </div>
          <div class="form-field" style="margin-bottom: 0.5rem;">
            <label style="display: block; font-weight: 500; margin-bottom: 0.25rem;">{% trans "Maximum Value" %}</label>
            <input type="number" name="fields-${index}-${config.maxField}" 
                   class="form-control" 
                   value="${fieldConfig[config.maxField] || ''}" 
                   placeholder="100" />
          </div>
        `;
        
        if (config.stepField) {
          html += `
            <div class="form-field" style="margin-bottom: 0.5rem;">
              <label style="display: block; font-weight: 500; margin-bottom: 0.25rem;">{% trans "Step Value" %}</label>
              <input type="number" name="fields-${index}-${config.stepField}" 
                     class="form-control" 
                     value="${fieldConfig[config.stepField] || '1'}" 
                     placeholder="1" />
              <small class="form-text">{% trans "Increment between values (e.g., 1, 5, 10)" %}</small>
            </div>
          `;
        }
        break;
        
      case 'formula':
        // Calculation formula
        html = `
          <div class="form-field" style="margin-bottom: 0.5rem;">
            <label style="display: block; font-weight: 500; margin-bottom: 0.25rem;">{% trans "Calculation Formula" %}</label>
            <textarea name="fields-${index}-formula" class="form-control" rows="3" 
                      placeholder="{field_key1} + {field_key2}">${fieldConfig.formula || ''}</textarea>
            <small class="form-text">
              {% trans "Use {field_key} to reference other fields. Operators: +, -, *, /, ()" %}
            </small>
          </div>
        `;
        break;
    }
    
    return html;
  }
  
  /**
   * Update field settings panel based on field type
   */
  function updateFieldSettings(fieldRow, fieldType) {
    // Try to find field index from button or row
    let fieldIndex = fieldRow.querySelector('.toggle-field-settings')?.getAttribute('data-field-index');
    if (!fieldIndex) {
      // Try to extract from field name
      const fieldTypeSelect = fieldRow.querySelector('select[name*="field_type"]');
      if (fieldTypeSelect && fieldTypeSelect.name) {
        const match = fieldTypeSelect.name.match(/fields-(\d+)-/);
        if (match) fieldIndex = match[1];
      }
    }
    
    if (!fieldIndex && fieldIndex !== '0') {
      // Try to find from closest form row with index
      const allRows = document.querySelectorAll('tr.field-form-row');
      for (let i = 0; i < allRows.length; i++) {
        if (allRows[i] === fieldRow) {
          fieldIndex = i.toString();
          break;
        }
      }
    }
    
    if (!fieldIndex && fieldIndex !== '0') return;
    
    // Find the settings row
    let settingsRow = fieldRow.nextElementSibling;
    while (settingsRow && !settingsRow.classList.contains('field-settings-row')) {
      settingsRow = settingsRow.nextElementSibling;
    }
    
    if (!settingsRow) return;
    
    // Update data-field-type attribute
    settingsRow.setAttribute('data-field-type', fieldType);
    
    // Find the field-specific-settings container
    const settingsContainer = settingsRow.querySelector('.field-specific-settings');
    if (!settingsContainer) return;
    
    // Get existing field_config value from hidden input
    const fieldConfigInput = settingsRow.querySelector('input.field-config-json-input');
    let fieldConfig = {};
    
    console.log('üü¢ [LOAD] updateFieldSettings called for fieldIndex:', fieldIndex, 'fieldType:', fieldType);
    
    if (fieldConfigInput && fieldConfigInput.value) {
      console.log('üü¢ [LOAD] field_config input found, raw value:', fieldConfigInput.value);
      console.log('üü¢ [LOAD] field_config input value type:', typeof fieldConfigInput.value);
      
      let configValue = fieldConfigInput.value;
      
      // If value is an object (dict), convert to JSON string first
      if (typeof configValue === 'object' && configValue !== null) {
        console.log('üü¢ [LOAD] field_config value is an object, converting to JSON string');
        configValue = JSON.stringify(configValue);
        // Update the input value
        fieldConfigInput.value = configValue;
      }
      
      try {
        const trimmedValue = String(configValue).trim();
        if (trimmedValue) {
          fieldConfig = JSON.parse(trimmedValue);
          console.log('üü¢ [LOAD] Parsed field_config:', fieldConfig);
        } else {
          console.log('üü¢ [LOAD] Empty config value, using empty object');
        }
      } catch (e) {
        console.error('‚ùå [LOAD] JSON parse error:', e);
        console.error('‚ùå [LOAD] Failed to parse value:', configValue);
        // If JSON parsing fails, try to preserve existing options if they exist
        const existingOptionsListBody = settingsRow.querySelector('.options-list-body');
        if (existingOptionsListBody && existingOptionsListBody.querySelectorAll('tr.option-row').length > 0) {
          console.log('üü¢ [LOAD] JSON parse failed but existing options found, keeping UI state');
          // Don't reset - keep existing UI state
          return;
        }
        fieldConfig = {};
        console.log('üü¢ [LOAD] JSON parse failed, using empty object');
      }
    } else {
      console.log('üü¢ [LOAD] No field_config input or empty value, using empty object');
    }
    
    // Generate and set the HTML
    settingsContainer.innerHTML = generateFieldSettingsHTML(fieldType, fieldIndex, fieldConfig);
    
    // If it's an options field, handle source type toggle and load options
    if (FIELD_SETTINGS_CONFIG[fieldType] && FIELD_SETTINGS_CONFIG[fieldType].type === 'options') {
      const sourceSelect = settingsContainer.querySelector('.options-source-select');
      if (sourceSelect) {
        // Set initial value from field_config
        const initialSource = fieldConfig.options_source || 'manual';
        sourceSelect.value = initialSource;
        
        // Toggle panels based on initial value
        toggleOptionsSourcePanels(settingsContainer, initialSource);
        
        // If entity reference is selected, load sections
        if (initialSource === 'entity_reference') {
          const entityPanel = settingsContainer.querySelector('.entity-reference-panel');
          if (entityPanel) {
            const panelFieldIndex = entityPanel.getAttribute('data-field-index');
            if (panelFieldIndex === fieldIndex.toString()) {
              console.log('üîµ [ENTITY_REF] Entity reference panel found, loading sections for fieldIndex:', fieldIndex);
              
              // Load sections immediately
              setTimeout(() => {
                loadEntityReferenceSections(fieldIndex);
                
                // If entity_reference already exists in fieldConfig, try to parse and populate
                if (fieldConfig.entity_reference) {
                  console.log('üîµ [ENTITY_REF] Existing entity_reference found:', fieldConfig.entity_reference);
                  // Parse entity reference: section:action:params or section:action:param=value
                  const parts = fieldConfig.entity_reference.split(':');
                  if (parts.length >= 2) {
                    const sectionId = parts[0];
                    const actionName = parts[1];
                    let paramName = '';
                    let paramValue = '';
                    
                    // Parse parameter if exists (format: param=value)
                    if (parts.length >= 3 && parts[2].includes('=')) {
                      const paramParts = parts[2].split('=');
                      paramName = paramParts[0];
                      paramValue = paramParts.slice(1).join('='); // In case value contains '='
                    }
                    
                    // Wait for sections to load, then set section
                    setTimeout(() => {
                      const sectionSelect = entityPanel.querySelector('.entity-section-select');
                      if (sectionSelect) {
                        sectionSelect.value = sectionId;
                        loadEntityReferenceActions(fieldIndex, sectionId);
                        
                        // Wait a bit for actions to load, then set action
                        setTimeout(() => {
                          const actionSelect = entityPanel.querySelector('.entity-action-select');
                          if (actionSelect) {
                            actionSelect.value = actionName;
                            const actionOption = actionSelect.options[actionSelect.selectedIndex];
                            if (actionOption) {
                              loadEntityReferenceParameters(fieldIndex, actionOption);
                              
                              // Wait for parameters to load, then set parameter and value
                              if (paramName) {
                                setTimeout(() => {
                                  const paramSelect = entityPanel.querySelector('.entity-parameter-select');
                                  if (paramSelect) {
                                    paramSelect.value = paramName;
                                    loadEntityReferenceParameterValue(fieldIndex, paramName);
                                    
                                    // Wait a bit more, then set value
                                    setTimeout(() => {
                                      const paramValueInput = entityPanel.querySelector('.entity-parameter-value-input');
                                      if (paramValueInput) {
                                        paramValueInput.value = paramValue;
                                        updateEntityReferenceValue(fieldIndex);
                                      }
                                    }, 300);
                                  }
                                }, 300);
                              }
                            }
                          }
                        }, 500);
                      }
                    }, 500);
                  }
                }
              }, 100);
            }
          }
        }
        
        // Load manual options if available
        console.log('üü¢ [LOAD] initialSource:', initialSource);
        console.log('üü¢ [LOAD] fieldConfig.options:', fieldConfig.options);
        
        if (initialSource === 'manual' && fieldConfig.options && Array.isArray(fieldConfig.options)) {
          console.log('üü¢ [LOAD] Loading manual options, count:', fieldConfig.options.length);
          const optionsListBody = settingsContainer.querySelector(`.options-list-body[data-field-index="${fieldIndex}"]`);
          console.log('üü¢ [LOAD] Options list body found:', !!optionsListBody);
          
          if (optionsListBody) {
            fieldConfig.options.forEach(function(opt, idx) {
              console.log(`üü¢ [LOAD] Loading option ${idx}:`, opt);
              addOptionRow(optionsListBody, fieldIndex, opt);
            });
            console.log('üü¢ [LOAD] All options loaded');
          } else {
            console.error('‚ùå [LOAD] Options list body not found!');
          }
        } else {
          console.log('üü¢ [LOAD] Not loading options - initialSource:', initialSource, 'has options:', !!fieldConfig.options, 'is array:', Array.isArray(fieldConfig.options));
        }
        
        // Add change listener
        sourceSelect.addEventListener('change', function() {
          const sourceType = this.value;
          toggleOptionsSourcePanels(settingsContainer, sourceType);
          
          // If switching to entity_reference, load sections
          if (sourceType === 'entity_reference') {
            const entityPanel = settingsContainer.querySelector('.entity-reference-panel');
            if (entityPanel) {
              const panelFieldIndex = entityPanel.getAttribute('data-field-index');
              if (panelFieldIndex) {
                console.log('üîµ [ENTITY_REF] Options source changed to entity_reference, loading sections for fieldIndex:', panelFieldIndex);
                setTimeout(() => {
                  loadEntityReferenceSections(panelFieldIndex);
                }, 100);
              }
            }
          }
          
          // Save settings when source changes
          saveFieldSettingsToConfig(fieldRow);
        });
      }
    }
  }
  
  /**
   * Toggle between manual and entity reference options panels
   */
  function toggleOptionsSourcePanels(container, sourceType) {
    const manualPanel = container.querySelector('.manual-options-panel');
    const entityPanel = container.querySelector('.entity-reference-panel');
    
    if (sourceType === 'manual') {
      if (manualPanel) manualPanel.style.display = 'block';
      if (entityPanel) entityPanel.style.display = 'none';
    } else if (sourceType === 'entity_reference') {
      if (manualPanel) manualPanel.style.display = 'none';
      if (entityPanel) {
        entityPanel.style.display = 'block';
        
        // Load sections when panel becomes visible
        const fieldIndex = entityPanel.getAttribute('data-field-index');
        if (fieldIndex) {
          console.log('üîµ [ENTITY_REF] Entity reference panel shown, loading sections for fieldIndex:', fieldIndex);
          setTimeout(() => {
            loadEntityReferenceSections(fieldIndex);
          }, 100);
        }
      }
    }
  }
  
  /**
   * Add a new option row to the options table
   */
  function addOptionRow(optionsListBody, fieldIndex, optionData = null) {
    const optionIndex = optionsListBody.querySelectorAll('tr.option-row').length;
    const option = optionData || { value: '', label: '', order: optionIndex, is_default: false };
    
    const row = document.createElement('tr');
    row.className = 'option-row';
    row.setAttribute('data-option-index', optionIndex);
    
    row.innerHTML = `
      <td style="padding: 0.5rem; width: 80px;">
        <input type="number" 
               class="form-control option-order" 
               value="${option.order !== undefined ? option.order : optionIndex}" 
               min="0" 
               style="width: 100%; font-size: 0.875rem;" />
      </td>
      <td style="padding: 0.5rem;">
        <input type="text" 
               class="form-control option-value" 
               value="${option.value || ''}" 
               placeholder="{% trans 'Value' %}" 
               required 
               style="font-size: 0.875rem;" />
      </td>
      <td style="padding: 0.5rem;">
        <input type="text" 
               class="form-control option-label" 
               value="${option.label || ''}" 
               placeholder="{% trans 'Label' %}" 
               required 
               style="font-size: 0.875rem;" />
      </td>
      <td style="padding: 0.5rem; text-align: center; width: 80px;">
        <input type="checkbox" 
               class="form-check-input option-default" 
               ${option.is_default ? 'checked' : ''} 
               style="margin: 0 auto;" />
      </td>
      <td style="padding: 0.5rem; text-align: center; width: 100px;">
        <button type="button" 
                class="btn btn-sm btn-danger remove-option-btn" 
                data-field-index="${fieldIndex}" 
                data-option-index="${optionIndex}"
                style="padding: 0.25rem 0.5rem; font-size: 0.75rem;">
          üóëÔ∏è {% trans "Remove" %}
        </button>
      </td>
    `;
    
    optionsListBody.appendChild(row);
    
    // Update order numbers
    updateOptionOrders(optionsListBody);
    
    // Add event listeners
    const removeBtn = row.querySelector('.remove-option-btn');
    if (removeBtn) {
      removeBtn.addEventListener('click', function() {
        row.remove();
        updateOptionOrders(optionsListBody);
        
        // Save settings after removal
        const settingsRow = optionsListBody.closest('.field-settings-row');
        if (settingsRow) {
          let fieldRow = settingsRow.previousElementSibling;
          while (fieldRow && !fieldRow.classList.contains('field-form-row')) {
            fieldRow = fieldRow.previousElementSibling;
          }
          if (fieldRow) {
            saveFieldSettingsToConfig(fieldRow);
          }
        }
      });
    }
    
    // Add change listeners for auto-save
    const valueInput = row.querySelector('.option-value');
    const labelInput = row.querySelector('.option-label');
    const orderInput = row.querySelector('.option-order');
    const defaultCheck = row.querySelector('.option-default');
    
    [valueInput, labelInput, orderInput, defaultCheck].forEach(function(input) {
      if (input) {
        input.addEventListener('change', function() {
          const settingsRow = optionsListBody.closest('.field-settings-row');
          if (settingsRow) {
            let fieldRow = settingsRow.previousElementSibling;
            while (fieldRow && !fieldRow.classList.contains('field-form-row')) {
              fieldRow = fieldRow.previousElementSibling;
            }
            if (fieldRow) {
              saveFieldSettingsToConfig(fieldRow);
            }
          }
        });
      }
    });
    
    // Handle default checkbox - only one can be checked
    if (defaultCheck) {
      defaultCheck.addEventListener('change', function() {
        if (this.checked) {
          // Uncheck all other default checkboxes in the same field
          const allDefaultChecks = optionsListBody.querySelectorAll('.option-default');
          allDefaultChecks.forEach(function(check) {
            if (check !== this) {
              check.checked = false;
            }
          }, this);
        }
        
        // Save settings
        const settingsRow = optionsListBody.closest('.field-settings-row');
        if (settingsRow) {
          let fieldRow = settingsRow.previousElementSibling;
          while (fieldRow && !fieldRow.classList.contains('field-form-row')) {
            fieldRow = fieldRow.previousElementSibling;
          }
          if (fieldRow) {
            saveFieldSettingsToConfig(fieldRow);
          }
        }
      });
    }
  }
  
  /**
   * Update order numbers for all options
   */
  function updateOptionOrders(optionsListBody) {
    const optionRows = optionsListBody.querySelectorAll('tr.option-row');
    optionRows.forEach(function(row, idx) {
      const orderInput = row.querySelector('.option-order');
      if (orderInput) {
        orderInput.value = idx;
      }
      row.setAttribute('data-option-index', idx);
      const removeBtn = row.querySelector('.remove-option-btn');
      if (removeBtn) {
        removeBtn.setAttribute('data-option-index', idx);
      }
    });
  }
  
  // Handle "Add Option" button clicks
  document.addEventListener('click', function(e) {
    if (e.target.closest('.add-option-btn')) {
      const button = e.target.closest('.add-option-btn');
      const fieldIndex = button.getAttribute('data-field-index');
      const settingsRow = button.closest('.field-settings-row');
      
      if (settingsRow) {
        const optionsListBody = settingsRow.querySelector(`.options-list-body[data-field-index="${fieldIndex}"]`);
        if (optionsListBody) {
          addOptionRow(optionsListBody, fieldIndex);
          
          // Save settings after adding
          let fieldRow = settingsRow.previousElementSibling;
          while (fieldRow && !fieldRow.classList.contains('field-form-row')) {
            fieldRow = fieldRow.previousElementSibling;
          }
          if (fieldRow) {
            saveFieldSettingsToConfig(fieldRow);
          }
        }
      }
    }
  });
  
  /**
   * Save field settings to field_config JSON
   */
  function saveFieldSettingsToConfig(fieldRow) {
    console.log('üîµ [SAVE] saveFieldSettingsToConfig called');
    
    // Find field index
    let fieldIndex = fieldRow.querySelector('.toggle-field-settings')?.getAttribute('data-field-index');
    console.log('üîµ [SAVE] Initial fieldIndex from button:', fieldIndex);
    
    if (!fieldIndex) {
      const fieldTypeSelect = fieldRow.querySelector('select[name*="field_type"]');
      if (fieldTypeSelect && fieldTypeSelect.name) {
        const match = fieldTypeSelect.name.match(/fields-(\d+)-/);
        if (match) fieldIndex = match[1];
        console.log('üîµ [SAVE] fieldIndex extracted from field_type name:', fieldIndex);
      }
    }
    
    if (!fieldIndex && fieldIndex !== '0') {
      const allRows = document.querySelectorAll('tr.field-form-row');
      for (let i = 0; i < allRows.length; i++) {
        if (allRows[i] === fieldRow) {
          fieldIndex = i.toString();
          console.log('üîµ [SAVE] fieldIndex found by iterating rows:', fieldIndex);
          break;
        }
      }
    }
    
    if (!fieldIndex && fieldIndex !== '0') {
      console.error('‚ùå [SAVE] Could not find fieldIndex, returning');
      return;
    }
    
    console.log('üîµ [SAVE] Using fieldIndex:', fieldIndex);
    
    // Find settings row
    let settingsRow = fieldRow.nextElementSibling;
    while (settingsRow && !settingsRow.classList.contains('field-settings-row')) {
      settingsRow = settingsRow.nextElementSibling;
    }
    
    if (!settingsRow) {
      console.error('‚ùå [SAVE] Settings row not found, returning');
      return;
    }
    
    console.log('üîµ [SAVE] Settings row found');
    
    // Find field_config hidden input
    const fieldConfigInput = settingsRow.querySelector('input.field-config-json-input');
    if (!fieldConfigInput) {
      console.error('‚ùå [SAVE] field_config input not found, returning');
      return;
    }
    
    console.log('üîµ [SAVE] field_config input found, current value:', fieldConfigInput.value);
    
    const fieldType = settingsRow.getAttribute('data-field-type');
    console.log('üîµ [SAVE] Field type:', fieldType);
    
    const config = FIELD_SETTINGS_CONFIG[fieldType];
    if (!config || config.type === 'none') {
      console.log('üîµ [SAVE] Field has no special settings, setting empty object');
      fieldConfigInput.value = '{}';
      return;
    }
    
    const fieldConfig = {};
    
    // Collect settings based on field type
    switch (config.type) {
      case 'options':
        console.log('üîµ [SAVE] Processing options field type');
        const sourceSelect = settingsRow.querySelector(`[name="fields-${fieldIndex}-options_source"]`);
        console.log('üîµ [SAVE] Source select found:', !!sourceSelect, sourceSelect ? 'value: ' + sourceSelect.value : '');
        
        if (sourceSelect) {
          fieldConfig.options_source = sourceSelect.value;
          console.log('üîµ [SAVE] options_source set to:', fieldConfig.options_source);
          
          if (sourceSelect.value === 'entity_reference') {
            console.log('üîµ [SAVE] Using entity_reference mode');
            
            // Update entity reference value before saving
            updateEntityReferenceValue(fieldIndex);
            
            // Get values from hidden inputs (updated by JavaScript)
            const hiddenEntityRef = settingsRow.querySelector(`input.entity-reference-hidden[name="fields-${fieldIndex}-entity_reference"]`);
            const hiddenValueField = settingsRow.querySelector(`input.entity-value-field-hidden[name="fields-${fieldIndex}-value_field"]`);
            const hiddenLabelField = settingsRow.querySelector(`input.entity-label-field-hidden[name="fields-${fieldIndex}-label_field"]`);
            
            if (hiddenEntityRef && hiddenEntityRef.value) fieldConfig.entity_reference = hiddenEntityRef.value;
            if (hiddenValueField && hiddenValueField.value) fieldConfig.value_field = hiddenValueField.value;
            if (hiddenLabelField && hiddenLabelField.value) fieldConfig.label_field = hiddenLabelField.value;
            
            // Clear manual options if using entity reference
            delete fieldConfig.options;
            console.log('üîµ [SAVE] Entity reference config:', fieldConfig);
          } else if (sourceSelect.value === 'manual') {
            console.log('üîµ [SAVE] Using manual mode - looking for options');
            // Save manual options
            const optionsListBody = settingsRow.querySelector(`.options-list-body[data-field-index="${fieldIndex}"]`);
            console.log('üîµ [SAVE] Options list body found:', !!optionsListBody);
            
            if (optionsListBody) {
              const options = [];
              const optionRows = optionsListBody.querySelectorAll('tr.option-row');
              console.log('üîµ [SAVE] Found option rows:', optionRows.length);
              
              optionRows.forEach(function(row, idx) {
                const valueInput = row.querySelector('input.option-value');
                const labelInput = row.querySelector('input.option-label');
                const defaultCheck = row.querySelector('input.option-default');
                
                console.log(`üîµ [SAVE] Option row ${idx}: value="${valueInput ? valueInput.value : 'null'}", label="${labelInput ? labelInput.value : 'null'}", default=${defaultCheck ? defaultCheck.checked : 'null'}`);
                
                if (valueInput && labelInput && valueInput.value && labelInput.value) {
                  const option = {
                    value: valueInput.value.trim(),
                    label: labelInput.value.trim(),
                    order: idx,
                    is_default: defaultCheck ? defaultCheck.checked : false
                  };
                  options.push(option);
                  console.log(`üîµ [SAVE] Added option ${idx}:`, option);
                } else {
                  console.log(`üîµ [SAVE] Skipped option row ${idx} (empty or invalid)`);
                }
              });
              
              console.log('üîµ [SAVE] Total options collected:', options.length);
              if (options.length > 0) {
                fieldConfig.options = options;
                console.log('üîµ [SAVE] Options array set in fieldConfig:', fieldConfig.options);
              } else {
                delete fieldConfig.options;
                console.log('üîµ [SAVE] No valid options, deleted options from fieldConfig');
              }
            } else {
              console.error('‚ùå [SAVE] Options list body not found for fieldIndex:', fieldIndex);
            }
          }
        } else {
          console.error('‚ùå [SAVE] Source select not found!');
        }
        break;
        
      case 'auto_fill':
        const autoFillCheck = settingsRow.querySelector(`[name="fields-${fieldIndex}-${config.fieldName}"]`);
        if (autoFillCheck) {
          fieldConfig[config.fieldName] = autoFillCheck.checked;
        }
        break;
        
      case 'number':
        const separatorCheck = settingsRow.querySelector(`[name="fields-${fieldIndex}-thousands_separator"]`);
        if (separatorCheck) {
          fieldConfig.thousands_separator = separatorCheck.checked;
        }
        break;
        
      case 'range':
        const minInput = settingsRow.querySelector(`[name="fields-${fieldIndex}-${config.minField}"]`);
        const maxInput = settingsRow.querySelector(`[name="fields-${fieldIndex}-${config.maxField}"]`);
        if (minInput && minInput.value) fieldConfig[config.minField] = parseFloat(minInput.value);
        if (maxInput && maxInput.value) fieldConfig[config.maxField] = parseFloat(maxInput.value);
        if (config.stepField) {
          const stepInput = settingsRow.querySelector(`[name="fields-${fieldIndex}-${config.stepField}"]`);
          if (stepInput && stepInput.value) fieldConfig[config.stepField] = parseFloat(stepInput.value);
        }
        break;
        
      case 'formula':
        const formulaInput = settingsRow.querySelector(`[name="fields-${fieldIndex}-formula"]`);
        if (formulaInput && formulaInput.value) {
          fieldConfig.formula = formulaInput.value;
        }
        break;
    }
    
    // Update field_config hidden input
    const configJson = JSON.stringify(fieldConfig);
    fieldConfigInput.value = configJson;
    console.log('üîµ [SAVE] Final field_config JSON:', configJson);
    console.log('üîµ [SAVE] Hidden input value after update:', fieldConfigInput.value);
  }
  
  // Auto-save settings when they change
  fieldFormsetBody.addEventListener('change', function(e) {
    // Check if this is a field setting input (not the form field itself)
    if (e.target.closest('.field-settings-row')) {
      const settingsRow = e.target.closest('.field-settings-row');
      let fieldRow = settingsRow.previousElementSibling;
      while (fieldRow && !fieldRow.classList.contains('field-form-row')) {
        fieldRow = fieldRow.previousElementSibling;
      }
      if (fieldRow) {
        saveFieldSettingsToConfig(fieldRow);
      }
    }
  });
  
  // Initialize field settings for existing fields
  function initializeFieldSettings() {
    console.log('üü° [INIT] initializeFieldSettings called');
    const fieldRows = document.querySelectorAll('tr.field-form-row');
    console.log('üü° [INIT] Found field rows:', fieldRows.length);
    
    fieldRows.forEach(function(fieldRow, idx) {
      console.log(`üü° [INIT] Processing field row ${idx}`);
      
      // Log the initial field_config value
      let settingsRow = fieldRow.nextElementSibling;
      while (settingsRow && !settingsRow.classList.contains('field-settings-row')) {
        settingsRow = settingsRow.nextElementSibling;
      }
      if (settingsRow) {
        const fieldConfigInput = settingsRow.querySelector('input.field-config-json-input');
        if (fieldConfigInput) {
          console.log(`üü° [INIT] Field row ${idx} initial field_config (raw):`, fieldConfigInput.value);
          console.log(`üü° [INIT] Field row ${idx} initial field_config type:`, typeof fieldConfigInput.value);
          
          // If value looks like Python dict representation, try to convert it
          let configValue = fieldConfigInput.value;
          if (configValue && typeof configValue === 'string') {
            // Check if it looks like Python dict (starts with '{' but might be Python dict format)
            if (configValue.trim().startsWith('{') && !configValue.trim().startsWith('{"')) {
              console.log(`üü° [INIT] Field row ${idx} field_config looks like Python dict, attempting conversion`);
              // Try to parse as Python dict literal and convert to JSON
              try {
                // Replace Python True/False/None with JSON true/false/null
                let jsonStr = configValue.replace(/True/g, 'true').replace(/False/g, 'false').replace(/None/g, 'null');
                jsonStr = jsonStr.replace(/'/g, '"'); // Replace single quotes with double quotes
                const parsed = JSON.parse(jsonStr);
                configValue = JSON.stringify(parsed);
                fieldConfigInput.value = configValue;
                console.log(`üü° [INIT] Field row ${idx} field_config converted to JSON:`, configValue);
              } catch (e) {
                console.error(`üü° [INIT] Field row ${idx} failed to convert Python dict:`, e);
              }
            }
          }
          
          console.log(`üü° [INIT] Field row ${idx} initial field_config (final):`, fieldConfigInput.value);
        }
      }
      
      const fieldTypeSelect = fieldRow.querySelector('select[name*="field_type"]');
      if (fieldTypeSelect && fieldTypeSelect.value) {
        console.log(`üü° [INIT] Field row ${idx} field_type:`, fieldTypeSelect.value);
        updateFieldSettings(fieldRow, fieldTypeSelect.value);
      } else {
        console.log(`üü° [INIT] Field row ${idx} has no field_type`);
      }
    });
    
    console.log('üü° [INIT] initializeFieldSettings completed');
  }
  
  // Listen for field type changes
  fieldFormsetBody.addEventListener('change', function(e) {
    if (e.target.name && e.target.name.includes('field_type')) {
      const fieldRow = e.target.closest('tr.field-form-row');
      if (fieldRow) {
        updateFieldSettings(fieldRow, e.target.value);
        
        // If settings panel is open, save settings before changing
        const settingsRow = fieldRow.nextElementSibling;
        if (settingsRow && settingsRow.classList.contains('field-settings-row') && 
            settingsRow.style.display !== 'none') {
          saveFieldSettingsToConfig(fieldRow);
        }
      }
    }
  });
  
  // Save settings to field_config when form is submitted
  const form = fieldFormsetBody.closest('form');
  if (form) {
    form.addEventListener('submit', function(e) {
      console.log('üü° [SUBMIT] ====================================================================');
      console.log('üü° [SUBMIT] Form submit event triggered');
      
      // Save all field settings to their field_config before submit
      const allFieldRows = document.querySelectorAll('tr.field-form-row');
      console.log('üü° [SUBMIT] Found field rows:', allFieldRows.length);
      
      allFieldRows.forEach(function(fieldRow, idx) {
        console.log(`üü° [SUBMIT] ========== Processing Field Row ${idx} ==========`);
        
        // Check field type
        const fieldTypeSelect = fieldRow.querySelector('select[name*="field_type"]');
        const fieldType = fieldTypeSelect ? fieldTypeSelect.value : 'NOT FOUND';
        console.log(`üü° [SUBMIT] Field ${idx} type:`, fieldType);
        
        // Save settings
        console.log(`üü° [SUBMIT] Saving settings for field row ${idx}...`);
        saveFieldSettingsToConfig(fieldRow);
        
        // Also log the final field_config value
        let settingsRow = fieldRow.nextElementSibling;
        while (settingsRow && !settingsRow.classList.contains('field-settings-row')) {
          settingsRow = settingsRow.nextElementSibling;
        }
        if (settingsRow) {
          const fieldConfigInput = settingsRow.querySelector('input.field-config-json-input');
          if (fieldConfigInput) {
            console.log(`üü° [SUBMIT] Field ${idx} final field_config:`, fieldConfigInput.value);
            console.log(`üü° [SUBMIT] Field ${idx} field_config input name:`, fieldConfigInput.name);
            
            // Check if options exist in the UI (for dropdown, radio, etc.)
            if (fieldType === 'dropdown' || fieldType === 'radio' || fieldType === 'checkbox' || fieldType === 'multi_select') {
              const sourceSelect = settingsRow.querySelector('.options-source-select');
              console.log(`üü° [SUBMIT] Field ${idx} options_source:`, sourceSelect ? sourceSelect.value : 'NOT FOUND');
              
              const optionsListBody = settingsRow.querySelector('.options-list-body');
              if (optionsListBody) {
                const optionRows = optionsListBody.querySelectorAll('tr.option-row');
                console.log(`üü° [SUBMIT] Field ${idx} has ${optionRows.length} option rows in UI`);
                optionRows.forEach(function(optRow, optIdx) {
                  const valueInput = optRow.querySelector('input.option-value');
                  const labelInput = optRow.querySelector('input.option-label');
                  const defaultCheck = optRow.querySelector('input.option-default');
                  console.log(`üü° [SUBMIT] Field ${idx} Option ${optIdx}: value="${valueInput ? valueInput.value : ''}", label="${labelInput ? labelInput.value : ''}", default=${defaultCheck ? defaultCheck.checked : false}`);
                });
              } else {
                console.log(`üü° [SUBMIT] Field ${idx} options_list_body NOT FOUND`);
              }
              
              // Try to parse the field_config JSON
              try {
                const parsed = JSON.parse(fieldConfigInput.value || '{}');
                console.log(`üü° [SUBMIT] Field ${idx} parsed field_config:`, parsed);
                if (parsed.options && Array.isArray(parsed.options)) {
                  console.log(`üü° [SUBMIT] Field ${idx} has ${parsed.options.length} options in field_config:`, parsed.options);
                } else {
                  console.log(`üü° [SUBMIT] Field ${idx} NO OPTIONS in field_config`);
                }
              } catch (e) {
                console.error(`üü° [SUBMIT] Field ${idx} JSON parse error:`, e);
              }
            }
          } else {
            console.log(`üü° [SUBMIT] Field ${idx} field_config input NOT FOUND`);
          }
        } else {
          console.log(`üü° [SUBMIT] Field ${idx} settings row NOT FOUND`);
        }
        console.log(`üü° [SUBMIT] ========== End Field Row ${idx} ==========`);
      });
      
      // Log all field_config inputs in form
      console.log('üü° [SUBMIT] All field_config inputs in form:');
      const allConfigInputs = form.querySelectorAll('input.field-config-json-input');
      allConfigInputs.forEach(function(input, idx) {
        console.log(`üü° [SUBMIT] Config input ${idx}: name="${input.name}", value="${input.value}"`);
      });
      
      console.log('üü° [SUBMIT] ====================================================================');
      console.log('üü° [SUBMIT] Submitting form...');
    });
  }
  
  // ========================================================================
  // Entity Reference System - Three-Level Configuration
  // ========================================================================
  
  /**
   * Load sections from API and populate dropdown
   */
  function loadEntityReferenceSections(fieldIndex) {
    console.log('üîµ [ENTITY_REF] loadEntityReferenceSections called for fieldIndex:', fieldIndex);
    const sectionSelect = document.querySelector(`select.entity-section-select[data-field-index="${fieldIndex}"]`);
    console.log('üîµ [ENTITY_REF] Section select found:', !!sectionSelect, sectionSelect);
    
    if (!sectionSelect) {
      console.error('üîµ [ENTITY_REF] Section select not found for fieldIndex:', fieldIndex);
      return;
    }
    
    if (sectionSelect.options.length > 1) {
      console.log('üîµ [ENTITY_REF] Sections already loaded, count:', sectionSelect.options.length - 1);
      return;
    }
    
    const apiUrl = '{% url "ticketing:api_entity_reference_sections" %}';
    console.log('üîµ [ENTITY_REF] Fetching from URL:', apiUrl);
    
    // Get CSRF token
    const csrftoken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || '';
    console.log('üîµ [ENTITY_REF] CSRF token found:', !!csrftoken);
    
    fetch(apiUrl, {
      method: 'GET',
      headers: {
        'X-CSRFToken': csrftoken,
        'Content-Type': 'application/json',
      },
      credentials: 'same-origin',
    })
      .then(response => {
        console.log('üîµ [ENTITY_REF] Response status:', response.status, response.statusText);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        console.log('üîµ [ENTITY_REF] Data received:', data);
        console.log('üîµ [ENTITY_REF] Sections count:', data.sections ? data.sections.length : 0);
        
        if (!data.sections || !Array.isArray(data.sections)) {
          console.error('üîµ [ENTITY_REF] Invalid data format, expected sections array');
          return;
        }
        
        // Clear existing options (except the first "Select..." option)
        while (sectionSelect.options.length > 1) {
          sectionSelect.remove(1);
        }
        
        // Add sections (user can choose to display nickname OR code)
        data.sections.forEach((section, idx) => {
          console.log(`üîµ [ENTITY_REF] Adding section ${idx}:`, section);
          const option = document.createElement('option');
          option.value = section.nickname; // Use nickname as value (can be changed to code)
          option.textContent = section.name + ' (' + section.nickname + ')'; // Display: Name (nickname)
          option.setAttribute('data-code', section.code);
          sectionSelect.appendChild(option);
        });
        
        console.log('üîµ [ENTITY_REF] Sections loaded successfully, total options:', sectionSelect.options.length);
      })
      .catch(error => {
        console.error('üîµ [ENTITY_REF] Error loading sections:', error);
        console.error('üîµ [ENTITY_REF] Error details:', error.message, error.stack);
      });
  }
  
  /**
   * Load actions for selected section
   */
  function loadEntityReferenceActions(fieldIndex, sectionIdentifier) {
    const actionSelect = document.querySelector(`select.entity-action-select[data-field-index="${fieldIndex}"]`);
    if (!actionSelect || !sectionIdentifier) {
      return;
    }
    
    // Clear existing options
    actionSelect.innerHTML = '<option value="">{% trans "Select action..." %}</option>';
    actionSelect.disabled = true;
    
    // Clear parameters
    const paramsContainer = document.querySelector(`.entity-parameters-list[data-field-index="${fieldIndex}"]`);
    if (paramsContainer) {
      paramsContainer.innerHTML = '';
    }
    
    fetch(`{% url "ticketing:api_entity_reference_actions" %}?section_code=${encodeURIComponent(sectionIdentifier)}`)
      .then(response => response.json())
      .then(data => {
        // Add actions
        data.actions.forEach(action => {
          const option = document.createElement('option');
          option.value = action.action_name;
          option.textContent = action.action_label;
          option.setAttribute('data-schema', JSON.stringify(action.parameter_schema));
          actionSelect.appendChild(option);
        });
        
        actionSelect.disabled = false;
      })
      .catch(error => {
        console.error('Error loading actions:', error);
      });
  }
  
  /**
   * Load parameters for selected action - populate parameter dropdown
   */
  function loadEntityReferenceParameters(fieldIndex, actionOption) {
    const paramSelect = document.querySelector(`select.entity-parameter-select[data-field-index="${fieldIndex}"]`);
    const paramsContainer = document.querySelector(`.entity-parameters-list[data-field-index="${fieldIndex}"]`);
    const paramValueContainer = document.querySelector(`.entity-parameter-value-container[data-field-index="${fieldIndex}"]`);
    
    if (!paramSelect || !actionOption) {
      return;
    }
    
    // Clear parameter select and hide value container
    paramSelect.innerHTML = '<option value="">{% trans "Select parameter..." %}</option>';
    paramSelect.disabled = true;
    if (paramValueContainer) {
      paramValueContainer.style.display = 'none';
    }
    
    // Store parameter schema in hidden container
    const parameterSchema = JSON.parse(actionOption.getAttribute('data-schema') || '{}');
    
    if (paramsContainer) {
      paramsContainer.setAttribute('data-schema', JSON.stringify(parameterSchema));
    }
    
    if (!parameterSchema || Object.keys(parameterSchema).length === 0) {
      paramSelect.innerHTML = '<option value="">{% trans "No parameters available" %}</option>';
      return;
    }
    
    // Populate parameter dropdown
    Object.keys(parameterSchema).forEach(paramName => {
      const paramDef = parameterSchema[paramName];
      const option = document.createElement('option');
      option.value = paramName;
      const isRequired = paramDef.required !== false;
      const description = paramDef.description ? ` - ${paramDef.description}` : '';
      option.textContent = paramName + (isRequired ? ' *' : '') + description;
      option.setAttribute('data-param-def', JSON.stringify(paramDef));
      paramSelect.appendChild(option);
    });
    
    paramSelect.disabled = false;
  }
  
  /**
   * Load parameter value options when a parameter is selected
   */
  function loadEntityReferenceParameterValue(fieldIndex, paramName) {
    const paramsContainer = document.querySelector(`.entity-parameters-list[data-field-index="${fieldIndex}"]`);
    const paramValueContainer = document.querySelector(`.entity-parameter-value-container[data-field-index="${fieldIndex}"]`);
    const paramValueInput = document.querySelector(`input.entity-parameter-value-input[data-field-index="${fieldIndex}"]`);
    
    if (!paramsContainer || !paramValueContainer || !paramValueInput) {
      return;
    }
    
    // Hide container first
    paramValueContainer.style.display = 'none';
    paramValueInput.value = '';
    
    if (!paramName) {
      return;
    }
    
    // Get parameter definition from stored schema
    const schemaStr = paramsContainer.getAttribute('data-schema');
    if (!schemaStr) return;
    
    const parameterSchema = JSON.parse(schemaStr);
    const paramDef = parameterSchema[paramName];
    
    if (!paramDef) return;
    
    // Show container
    paramValueContainer.style.display = 'block';
    
    const paramType = paramDef.type || 'string';
    const hasEnum = paramDef.enum && Array.isArray(paramDef.enum);
    
    // Get section and action for context
    const sectionSelect = document.querySelector(`select.entity-section-select[data-field-index="${fieldIndex}"]`);
    const actionSelect = document.querySelector(`select.entity-action-select[data-field-index="${fieldIndex}"]`);
    const sectionIdentifier = sectionSelect ? sectionSelect.value : '';
    const actionName = actionSelect ? actionSelect.value : '';
    
    // Create or update datalist
    let datalist = paramValueContainer.querySelector('.entity-parameter-value-datalist');
    if (!datalist) {
      datalist = document.createElement('datalist');
      datalist.className = 'entity-parameter-value-datalist';
      datalist.setAttribute('data-field-index', fieldIndex);
      paramValueContainer.querySelector('.parameter-value-wrapper').appendChild(datalist);
    }
    datalist.id = `datalist_${fieldIndex}_${paramName}`;
    paramValueInput.setAttribute('list', datalist.id);
    datalist.innerHTML = '';
    
    // If has enum, populate directly
    if (hasEnum) {
      paramDef.enum.forEach(enumValue => {
        const option = document.createElement('option');
        option.value = enumValue;
        option.textContent = enumValue;
        datalist.appendChild(option);
      });
    } else {
      // Load values from API
      const url = new URL('{% url "ticketing:api_entity_reference_parameter_values" %}', window.location.origin);
      url.searchParams.set('parameter_name', paramName);
      url.searchParams.set('parameter_type', paramType);
      if (sectionIdentifier) url.searchParams.set('section_code', sectionIdentifier);
      if (actionName) url.searchParams.set('action_name', actionName);
      if (paramDef.enum) url.searchParams.set('parameter_enum', JSON.stringify(paramDef.enum));
      
      fetch(url)
        .then(response => response.json())
        .then(data => {
          if (data.values && data.values.length > 0) {
            data.values.forEach(value => {
              const option = document.createElement('option');
              option.value = value.value || value;
              option.textContent = value.label || value.value || value;
              datalist.appendChild(option);
            });
          }
        })
        .catch(error => {
          console.error('Error loading parameter values:', error);
        });
    }
    
    // Update entity reference value
    updateEntityReferenceValue(fieldIndex);
  }
  
  
  /**
   * Update entity reference hidden input when section/action/parameters change
   */
  function updateEntityReferenceValue(fieldIndex) {
    const sectionSelect = document.querySelector(`select.entity-section-select[data-field-index="${fieldIndex}"]`);
    const actionSelect = document.querySelector(`select.entity-action-select[data-field-index="${fieldIndex}"]`);
    const paramSelect = document.querySelector(`select.entity-parameter-select[data-field-index="${fieldIndex}"]`);
    const paramValueInput = document.querySelector(`input.entity-parameter-value-input[data-field-index="${fieldIndex}"]`);
    const hiddenInput = document.querySelector(`input.entity-reference-hidden[data-field-index="${fieldIndex}"]`);
    
    if (!sectionSelect || !actionSelect || !hiddenInput) return;
    
    const sectionValue = sectionSelect.value;
    const actionValue = actionSelect.value;
    
    if (!sectionValue || !actionValue) {
      hiddenInput.value = '';
      return;
    }
    
    // Build entity reference string: section:action:params
    let entityRef = sectionValue + ':' + actionValue;
    
    // Collect parameter if selected
    if (paramSelect && paramSelect.value && paramValueInput && paramValueInput.value) {
      const paramName = paramSelect.value;
      const paramValue = paramValueInput.value.trim();
      if (paramValue) {
        entityRef += ':' + paramName + '=' + paramValue;
      }
    }
    
    hiddenInput.value = entityRef;
    
    // Also update value_field and label_field (default to id and name)
    const valueFieldInput = document.querySelector(`input.entity-value-field-hidden[name="fields-${fieldIndex}-value_field"]`);
    const labelFieldInput = document.querySelector(`input.entity-label-field-hidden[name="fields-${fieldIndex}-label_field"]`);
    if (valueFieldInput && !valueFieldInput.value) valueFieldInput.value = 'id';
    if (labelFieldInput && !labelFieldInput.value) labelFieldInput.value = 'name';
  }
  
  // Event listeners for entity reference
  document.addEventListener('change', function(e) {
    // Section selection
    if (e.target.matches('.entity-section-select')) {
      const fieldIndex = e.target.getAttribute('data-field-index');
      loadEntityReferenceActions(fieldIndex, e.target.value);
      updateEntityReferenceValue(fieldIndex);
    }
    
    // Action selection
    if (e.target.matches('.entity-action-select')) {
      const fieldIndex = e.target.getAttribute('data-field-index');
      const selectedOption = e.target.options[e.target.selectedIndex];
      loadEntityReferenceParameters(fieldIndex, selectedOption);
      updateEntityReferenceValue(fieldIndex);
    }
    
    // Parameter selection
    if (e.target.matches('.entity-parameter-select')) {
      const fieldIndex = e.target.getAttribute('data-field-index');
      const paramName = e.target.value;
      loadEntityReferenceParameterValue(fieldIndex, paramName);
      updateEntityReferenceValue(fieldIndex);
    }
    
    // Parameter value change
    if (e.target.matches('.entity-parameter-value-input')) {
      const fieldIndex = e.target.getAttribute('data-field-index');
      updateEntityReferenceValue(fieldIndex);
    }
  });
  
  // Load sections when entity reference panel becomes visible (using a simpler approach)
  const checkAndLoadSections = function() {
    document.querySelectorAll('.entity-reference-panel').forEach(panel => {
      const display = window.getComputedStyle(panel).display;
      if (display !== 'none' && display !== '') {
        const fieldIndex = panel.getAttribute('data-field-index');
        const sectionSelect = panel.querySelector('.entity-section-select');
        if (sectionSelect && sectionSelect.options.length <= 1) {
          console.log('üîµ [ENTITY_REF] Panel visible, loading sections for fieldIndex:', fieldIndex);
          loadEntityReferenceSections(fieldIndex);
        }
      }
    });
  };
  
  // Check immediately
  setTimeout(checkAndLoadSections, 500);
  
  // Also check after DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', checkAndLoadSections);
  } else {
    checkAndLoadSections();
  }
  
  // Use MutationObserver as fallback
  const observer = new MutationObserver(function() {
    checkAndLoadSections();
  });
  
  // Observe document body for changes
  observer.observe(document.body, {
    childList: true,
    subtree: true,
    attributes: true,
    attributeFilter: ['style', 'class']
  });

  // Initialize on page load
  initializeFieldSettings();
  
  // ========================================================================
  // Toggle Field Settings Panel
  // ========================================================================
  document.addEventListener('click', function(e) {
    if (e.target.closest('.toggle-field-settings')) {
      const button = e.target.closest('.toggle-field-settings');
      const fieldIndex = button.getAttribute('data-field-index');
      
      // Find the settings row - it should be the next sibling row after the field row
      const fieldRow = button.closest('tr.field-form-row');
      if (fieldRow) {
        const fieldTypeSelect = fieldRow.querySelector('select[name*="field_type"]');
        const currentFieldType = fieldTypeSelect ? fieldTypeSelect.value : '';
        
        let nextRow = fieldRow.nextElementSibling;
        while (nextRow) {
          if (nextRow.classList.contains('field-settings-row')) {
            const storedFieldType = nextRow.getAttribute('data-field-type');
            const settingsContainer = nextRow.querySelector('.field-specific-settings');
            const hasContent = settingsContainer && settingsContainer.innerHTML.trim() !== '';
            
            if (nextRow.style.display === 'none' || nextRow.style.display === '') {
              // Opening panel - always update settings to ensure options are loaded from field_config
              if (currentFieldType) {
                updateFieldSettings(fieldRow, currentFieldType);
                
                // After settings are updated, check if entity reference panel should load sections
                setTimeout(() => {
                  const entityPanel = nextRow.querySelector('.entity-reference-panel');
                  if (entityPanel && window.getComputedStyle(entityPanel).display !== 'none') {
                    const panelFieldIndex = entityPanel.getAttribute('data-field-index');
                    if (panelFieldIndex) {
                      console.log('üîµ [ENTITY_REF] Settings panel opened, loading sections for fieldIndex:', panelFieldIndex);
                      loadEntityReferenceSections(panelFieldIndex);
                    }
                  }
                }, 200);
              }
              nextRow.style.display = 'table-row';
              button.innerHTML = '‚ñ≤ ‚öôÔ∏è {% trans "Settings" %}';
            } else {
              // Closing panel - save settings before closing
              saveFieldSettingsToConfig(fieldRow);
              nextRow.style.display = 'none';
              button.innerHTML = '‚ñº ‚öôÔ∏è {% trans "Settings" %}';
            }
            break;
          }
          nextRow = nextRow.nextElementSibling;
        }
      }
    }
  });
});
</script>
{% endblock %}

